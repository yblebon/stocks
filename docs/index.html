<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Financial Data Product Viewer</title> 
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.1.0/dist/chartjs-adapter-luxon.min.js"></script>


    <style>
        body { font-family: sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; display: flex; flex-direction: column; }
        
        /* NEW Clock Styling */
        #time-display {
            background-color: #f0f8ff; /* Light blue background */
            border: 1px solid #d0e8ff;
            padding: 10px 20px;
            margin-bottom: 20px;
            border-radius: 5px;
            display: flex;
            flex-wrap: wrap; /* Allows wrapping on smaller screens */
            gap: 15px;
            font-size: 0.9em;
            align-items: center;
        }
        .time-entry {
            flex: 1 1 auto; /* Allows flexible width */
            padding: 5px 10px;
            background-color: #fff;
            border-radius: 3px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            min-width: 150px;
        }
        .time-entry strong {
            display: block;
            font-size: 0.8em;
            color: #555;
            margin-bottom: 2px;
        }
        .time-entry span {
            font-weight: bold;
            color: #007bff;
        }
        
        h1 { border-bottom: 2px solid #eee; padding-bottom: 10px; }
        code { background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px; }
        .main-container { display: flex; gap: 20px; margin-top: 15px; }
        .left-panel { flex: 0 0 300px; }
        .content-panel { flex: 1; }

        /* Reduced Font Size for Dynamic Content Title */
        #content-title {
            font-size: 1.2em; 
            font-weight: 600; 
        }

        /* Filter Card Styling */
        #filter-card {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 20px;
            background-color: #f9f9f9;
            border-radius: 5px;
        }
        #filter-card label { display: block; margin-top: 10px; font-weight: bold; font-size: 0.9em; color: #555; }
        #filter-card select[multiple] { 
            width: 100%; 
            padding: 5px;
            margin-top: 3px; 
            box-sizing: border-box; 
            border: 1px solid #ccc; 
            border-radius: 4px;
            height: 100px; 
        }
        #load-all-button { 
            width: 100%;
            padding: 8px;
            margin-top: 15px;
            background-color: #d9534f; 
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #load-all-button:hover {
            background-color: #c9302c;
        }
        
        /* File List Styling (Kept, but hidden via HTML removal, to be safe) */
        #contents-list { list-style: none; padding: 0; }
        #contents-list li { padding: 8px 0; border-bottom: 1px dashed #eee; cursor: pointer; }
        .file { color: #1a73e8; }
        .file:hover { text-decoration: underline; }
        .dir { color: #007bff; font-weight: bold; }
        .error { color: red; font-weight: bold; }
        .loading { font-style: italic; color: #555; }
        
        /* Content Display Styling */
        #file-content-display { 
            background-color: #f8f8f8; 
            border: 1px solid #ddd; 
            padding: 15px; 
            min-height: 400px;
            overflow: auto;
        }
        
        /* DataFrame Card Styling */
        .data-card-container { 
            margin-bottom: 30px; 
            padding: 15px;
            border: 1px solid #e0e0e0; 
            border-radius: 8px; 
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); 
        }
        .data-card-container h3 {
            margin-top: 0;
            border-bottom: 2px solid #ddd; 
            padding-bottom: 5px;
            color: #17a2b8; 
        }
        .chart-wrapper {
            height: 300px; 
            width: 100%;
        }
        .data-card-container .note {
            font-size: 0.8em;
            color: #777;
            margin-top: 10px;
        }
        .error-message {
            color: #cc0000;
            font-weight: bold;
        }

        /* Table Toggle Styling */
        .data-table-container {
            max-height: 300px;
            overflow: auto;
            border: 1px solid #ccc;
            background-color: #fff;
            padding: 5px;
            display: none;
        }
        .data-table-container table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8em;
        }
        .data-table-container th, .data-table-container td {
            border: 1px solid #eee;
            padding: 4px 8px;
            text-align: left;
            white-space: nowrap;
        }
        .data-table-container th {
            background-color: #f0f0f0;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .table-toggle-button {
            padding: 6px 12px;
            background-color: #5bc0de;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            margin-right: 10px; /* Space between buttons */
        }
        .table-toggle-button:hover {
            background-color: #31b0d5;
        }
        /* Bookmark Button Styling */
        .bookmark-toggle-button {
            padding: 6px 12px;
            background-color: #4CAF50; /* Green */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        .bookmark-toggle-button:hover {
            background-color: #45a049;
        }
        /* Style for bookmarked state */
        .bookmark-toggle-button.bookmarked {
            background-color: #f0ad4e; /* Orange/Yellow for active bookmark */
            color: #333;
        }
        .bookmark-toggle-button.bookmarked:hover {
            background-color: #ec971f;
        }
    </style>
</head>
<body>
    
    <div id="time-display">
        Loading clocks... ‚è±Ô∏è
    </div>

    <h1>Financial Data Product Viewer</h1>
    
    <div class="main-container">
        
        <div class="left-panel">
            
            <div id="filter-card">
                <h2>Filter DataFrames</h2>
                <label for="select-source">Source (Ctrl/Cmd+Click for multiple)</label>
                <select id="select-source" multiple onchange="applyFilters()">
                    </select>

                <label for="select-category">Category (Ctrl/Cmd+Click for multiple)</label>
                <select id="select-category" multiple onchange="applyFilters()">
                    </select>

                <label for="select-instrument">Instrument (Ctrl/Cmd+Click for multiple)</label>
                <select id="select-instrument" multiple onchange="applyFilters()">
                    </select>

                <label for="select-date">Date (Ctrl/Cmd+Click for multiple)</label>
                <select id="select-date" multiple onchange="applyFilters()">
                    </select>
                
                <button id="load-all-button" onclick="loadAllFilteredDataFrames()">Load ALL Filtered DataFrames üìä</button>
            </div>
            
        </div>

        <div class="content-panel">
            <h2 id="content-title">Select a File</h2>
            <div id="file-content-display">
                Use the filters on the left and click "Load ALL Filtered DataFrames" to view multiple charts here.
            </div>
        </div>

    </div>

    <script>
        // Store config globally to access initialBookmarks
        let appConfig = {}; 

        // --- Time Zone Logic (Unchanged) ---
        const TIME_ZONES = [
            { name: "New York", zone: "America/New_York" },
            { name: "London", zone: "Europe/London" },
            { name: "Paris", zone: "Europe/Paris" },
            { name: "UTC", zone: "UTC" },
            { name: "Local", zone: Intl.DateTimeFormat().resolvedOptions().timeZone },
            { name: "Moscow", zone: "Europe/Moscow" },
            { name: "Tokyo", zone: "Asia/Tokyo" }
        ];

        function updateClocks() {
            const now = new Date();
            const timeData = [];

            TIME_ZONES.forEach(tz => {
                try {
                    const options = {
                        hour: '2-digit', minute: '2-digit', second: '2-digit',
                        hour12: false, 
                        timeZone: tz.zone
                    };
                    
                    const timeString = now.toLocaleTimeString('en-US', options);
                    
                    const timeInZone = new Date(now.toLocaleString('en-US', { timeZone: tz.zone }));

                    timeData.push({
                        name: tz.name,
                        timeString: timeString,
                        timeInZone: timeInZone 
                    });
                } catch (e) {
                    console.error(`Error fetching time for ${tz.name}:`, e);
                    timeData.push({ name: tz.name, timeString: 'Error', timeInZone: new Date(0) });
                }
            });

            timeData.sort((a, b) => a.timeInZone.getTime() - b.timeInZone.getTime());

            const timeDisplay = document.getElementById('time-display');
            let html = '';

            timeData.forEach(data => {
                html += `
                    <div class="time-entry">
                        <strong>${data.name}</strong>
                        <span>${data.timeString}</span>
                    </div>
                `;
            });
            
            timeDisplay.innerHTML = html;
        }

        updateClocks();
        setInterval(updateClocks, 1000); 
        // --- END Time Zone Logic ---


        const contentsList = { innerHTML: '' }; 
        const currentPathDisplay = { textContent: '', classList: { remove: () => {} } }; 

        const fileContentDisplay = document.getElementById('file-content-display');
        const contentTitle = document.getElementById('content-title');
        
        let allFileMetadata = []; 
        let currentlyRenderedFiles = [];
        const rawDataStore = new Map(); 

        const BOOKMARK_KEY = 'dataframe-bookmarked-files'; 

        // Simple utility function to generate stable colors for different columns
        function getColor(index) {
            const colors = [
                'rgb(75, 192, 192)', // Teal
                'rgb(255, 99, 132)', // Red
                'rgb(54, 162, 235)', // Blue
                'rgb(255, 206, 86)', // Yellow
                'rgb(153, 102, 255)',// Purple
                'rgb(255, 159, 64)', // Orange
                'rgb(201, 203, 207)' // Grey
            ];
            return colors[index % colors.length];
        }
        // -----------------------------------------------------------


        // --- Bookmark Functions (MODIFIED) ---

        /**
         * Prioritizes reading bookmarks from the global config file (if loaded),
         * then falls back to localStorage.
         */
        function getBookmarkedFiles() {
            // 1. Check Config for initial bookmarks
            if (appConfig.initialBookmarks && Array.isArray(appConfig.initialBookmarks) && appConfig.initialBookmarks.length > 0) {
                 // For now, let config overwrite local storage on page load for simplicity.
                 // We could merge them, but config-first approach is cleaner for a central default.
                 const uniqueBookmarks = [...new Set(appConfig.initialBookmarks)];
                 console.log("Loaded initial bookmarks from config.json.");
                 return uniqueBookmarks;
            }
            
            // 2. Fallback to Local Storage
            try {
                const saved = localStorage.getItem(BOOKMARK_KEY);
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                console.error('Error reading bookmarks from local storage:', e);
                return [];
            }
        }

        function saveBookmarkedFiles(fileNames) {
            try {
                // User-saved bookmarks always go to local storage
                localStorage.setItem(BOOKMARK_KEY, JSON.stringify(fileNames));
            } catch (e) {
                console.error('Error saving bookmarks to local storage:', e);
            }
        }

        function toggleFileBookmark(fileName, buttonId) {
            let bookmarks = getBookmarkedFiles();
            
            // If the bookmarks array came from the config, create a mutable copy 
            // before modification, ensuring we don't accidentally write the config 
            // list back to localStorage without user intent.
            const isFromConfig = appConfig.initialBookmarks && bookmarks.every(b => appConfig.initialBookmarks.includes(b));
            if (isFromConfig) {
                 // If all current bookmarks match the config set, we treat the local state 
                 // as based on config, but allow user changes to be persisted locally.
            }
            
            let currentLocalBookmarks = [];
            try {
                const saved = localStorage.getItem(BOOKMARK_KEY);
                currentLocalBookmarks = saved ? JSON.parse(saved) : (appConfig.initialBookmarks || []);
            } catch(e) { /* ignore */ }
            
            let workingSet = [...currentLocalBookmarks];

            const index = workingSet.indexOf(fileName);
            const button = document.getElementById(buttonId);
            
            if (index > -1) {
                // Remove bookmark
                workingSet.splice(index, 1);
                button.textContent = 'Bookmark this Chart ‚≠êÔ∏è';
                button.classList.remove('bookmarked');
                console.log(`Removed bookmark for: ${fileName}`);
            } else {
                // Add bookmark
                workingSet.push(fileName);
                button.textContent = 'Bookmarked! (Click to Remove) ‚úÖ';
                button.classList.add('bookmarked');
                console.log(`Added bookmark for: ${fileName}`);
            }
            
            saveBookmarkedFiles(workingSet);
            // Re-apply filters to refresh the state markers if necessary
            // (not strictly needed here since only the button state changes, but good practice)
        }
        
        // The rest of the JS logic remains largely the same, relying on the modified getBookmarkedFiles()

        async function loadBookmarkedFiles() {
            const bookmarkedFileNames = getBookmarkedFiles();
            
            if (bookmarkedFileNames.length === 0) return false;

            // Only look up files that match the bookmark names AND are actually in the fetched list
            const bookmarkedFilesInfo = allFileMetadata.filter(item => 
                bookmarkedFileNames.includes(item.name)
            );
            
            // Filter out any bookmarks that don't match available files
            const validBookmarkedFileNames = bookmarkedFilesInfo.map(item => item.name);
            
            // If the set of bookmarks from the config/local storage contains invalid names, 
            // only process the valid ones.
            if (bookmarkedFilesInfo.length > 0) {
                currentlyRenderedFiles = bookmarkedFilesInfo;
                await loadAllFilteredDataFrames();
                
                const uniqueValues = { source: new Set(), instrument: new Set(), category: new Set(), date: new Set() };

                bookmarkedFilesInfo.forEach(file => {
                    uniqueValues.source.add(file.source);
                    uniqueValues.instrument.add(file.instrument);
                    uniqueValues.category.add(file.category);
                    uniqueValues.date.add(file.date);
                });

                const formatSet = (set, fieldName) => {
                    if (set.size === 0) return '';
                    const values = Array.from(set).sort();
                    return `${fieldName}: ${values.join(', ')}`;
                };

                const titleParts = [
                    formatSet(uniqueValues.source, 'Sources'),
                    formatSet(uniqueValues.instrument, 'Instruments'),
                    formatSet(uniqueValues.category, 'Categories'),
                    formatSet(uniqueValues.date, 'Dates')
                ].filter(part => part.length > 0);

                let newTitle = `Loaded ${bookmarkedFilesInfo.length} Bookmarked Charts: `;
                if (titleParts.length > 0) {
                    newTitle += titleParts.join(' | ');
                } else {
                    newTitle += 'Metadata not found.';
                }

                contentTitle.textContent = newTitle;
                
                return true;
            }
            return false;
        }
        
        // --- Data Table Functions (Unchanged) ---

        function renderTable(dataObject, tableContainerId) {
            const container = document.getElementById(tableContainerId);
            if (!container) return;

            const indices = Object.keys(dataObject);
            if (indices.length === 0) {
                container.innerHTML = '<table><tr><td>No data records found.</td></tr></table>';
                return;
            }

            const columns = ['Index (Date/Time)', ...Object.keys(dataObject[indices[0]])];
            
            let html = '<table><thead><tr>';
            columns.forEach(col => {
                html += `<th>${col}</th>`;
            });
            html += '</tr></thead><tbody>';

            const rowsToDisplay = indices.slice(0, 50);

            rowsToDisplay.forEach(index => {
                const row = dataObject[index];
                html += '<tr>';

                let displayIndex = index;
                const indexNum = Number(index);
                if (!isNaN(indexNum) && String(index).length === 13) {
                    try {
                        displayIndex = luxon.DateTime.fromMillis(indexNum).toFormat('yyyy-MM-dd HH:mm:ss');
                    } catch (e) {
                        displayIndex = index;
                    }
                }
                
                html += `<td>${displayIndex}</td>`; 
                
                columns.slice(1).forEach(col => {
                    const value = row[col];
                    const formattedValue = (typeof value === 'number' && !Number.isInteger(value)) 
                        ? value.toFixed(4) : value;
                    html += `<td>${formattedValue}</td>`;
                });
                html += '</tr>';
            });

            if (indices.length > 50) {
                html += `<tr><td colspan="${columns.length}" style="text-align:center; font-style:italic;">... Showing first 50 of ${indices.length} rows ...</td></tr>`;
            }

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function toggleDataTable(chartId, cardId) {
            const chartWrapper = document.getElementById(`${cardId}-chart-wrapper`);
            const tableContainer = document.getElementById(`${cardId}-table-container`);
            const button = document.getElementById(`${cardId}-toggle-button`);
            const rawData = rawDataStore.get(chartId); 

            if (!chartWrapper || !tableContainer || !button || !rawData) return;

            if (chartWrapper.style.display !== 'none') {
                renderTable(rawData, `${cardId}-table-container`);
                chartWrapper.style.display = 'none';
                tableContainer.style.display = 'block';
                button.textContent = 'Hide Source Data üìà';
            } else {
                tableContainer.style.display = 'none';
                chartWrapper.style.display = 'block';
                button.textContent = 'Show Source Data üìã';
            }
        }

        // --- Core Chart Initialization Function (Unchanged) ---
        function initializeChart(chartId, datasets, title) {
            const ctx = document.getElementById(chartId);
            if (!ctx) return; 

            if (Chart.getChart(ctx)) {
                Chart.getChart(ctx).destroy();
            }
            
            const chartDatasets = datasets.map((d, index) => { 
                const color = getColor(index);
                return {
                    label: d.label,
                    data: d.data,
                    borderColor: color,
                    backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.2)'),
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1,
                    hidden: index !== 0 
                };
            });


            new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: chartDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true, 
                            position: 'bottom',
                            labels: {
                                usePointStyle: true
                            }
                        },
                        title: { 
                            display: true,
                            text: title
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                parser: false, 
                                unit: 'day',
                                tooltipFormat: 'yyyy-MM-dd HH:mm',
                                displayFormats: {
                                    day: 'yyyy-MM-dd',
                                    hour: 'HH:mm'
                                }
                            },
                            title: { display: true, text: 'Date (YYYY-MM-DD)' },
                            ticks: { 
                                maxTicksLimit: 10,
                                autoSkip: true
                            }
                        },
                        y: {
                            title: { display: true, text: 'Value' }
                        }
                    }
                }
            });
        }
        
        // --- Helper Function for Chart Card Generation (Unchanged) ---
        function jsonToChartCard(dataObject, fileInfo) {
            const indices = Object.keys(dataObject);
            const numRecords = indices.length;
            const cardId = `card-${fileInfo.name.replace(/[^a-zA-Z0-9]/g, '_')}`; 
            const chartId = `chart-${fileInfo.name.replace(/[^a-zA-Z0-9]/g, '_')}`; 
            const buttonId = `${cardId}-bookmark-button`;
            
            rawDataStore.set(chartId, dataObject);

            // Check if file is bookmarked based on combined config/local state
            const isBookmarked = getBookmarkedFiles().includes(fileInfo.name);
            const bookmarkText = isBookmarked ? 'Bookmarked! (Click to Remove) ‚úÖ' : 'Bookmark this Chart ‚≠êÔ∏è';
            const bookmarkClass = isBookmarked ? 'bookmark-toggle-button bookmarked' : 'bookmark-toggle-button';


            let metadataHtml = `
                <h3>${fileInfo.source} | ${fileInfo.instrument} | ${fileInfo.category} | ${fileInfo.date}</h3>
                <p class="note">${numRecords} total records found. Chart displays the first 100 data points. **Handles both ISO date strings and millisecond timestamps.** Click the legend items to toggle traces.</p>
            `;

            if (numRecords === 0) {
                return { 
                    html: `<div class="data-card-container" id="${cardId}">${metadataHtml}<p class="error-message">DataFrame is empty.</p></div>`,
                    chartData: null
                };
            }

            const firstRecord = dataObject[indices[0]];
            if (!firstRecord) {
                 return { 
                    html: `<div class="data-card-container" id="${cardId}">${metadataHtml}<p class="error-message">DataFrame has records but the first one is invalid.</p></div>`,
                    chartData: null
                };
            }

            const availableColumns = Object.keys(firstRecord);
            const allDatasets = [];
            
            const rowsToDisplay = indices.slice(0, 100);
            
            for (const col of availableColumns) {
                const dataPoints = [];
                let hasNumericData = false;

                rowsToDisplay.forEach(dateString => {
                    const value = dataObject[dateString][col];
                    const numericValue = parseFloat(value);

                    const indexNum = Number(dateString);
                    const isTimestamp = !isNaN(indexNum) && String(dateString).length === 13;
                    const xValue = isTimestamp ? indexNum : dateString; 

                    if (isNaN(numericValue)) {
                        dataPoints.push({ x: xValue, y: null });
                    } else {
                        dataPoints.push({ x: xValue, y: numericValue });
                        hasNumericData = true;
                    }
                });

                if (hasNumericData) {
                    allDatasets.push({
                        label: col.charAt(0).toUpperCase() + col.slice(1), 
                        data: dataPoints 
                    });
                }
            }
            
            if (allDatasets.length === 0) {
                 return {
                    html: `<div class="data-card-container error" id="${cardId}">
                        ${metadataHtml}
                        <p class="error-message">Error: No numeric columns found in this DataFrame to plot.</p>
                    </div>`,
                    chartData: null
                };
            }


            const cardHtml = `
                <div class="data-card-container" id="${cardId}">
                    ${metadataHtml}
                    
                    <button class="table-toggle-button" id="${cardId}-toggle-button" 
                            onclick="toggleDataTable('${chartId}', '${cardId}')">
                        Show Source Data üìã
                    </button>
                    
                    <button class="${bookmarkClass}" id="${buttonId}" 
                            onclick="toggleFileBookmark('${fileInfo.name}', '${buttonId}')">
                        ${bookmarkText}
                    </button>

                    <div class="chart-wrapper" id="${cardId}-chart-wrapper" style="display: block;">
                        <canvas id="${chartId}"></canvas>
                    </div>

                    <div class="data-table-container" id="${cardId}-table-container" style="display: none;">
                    </div>
                </div>
            `;
            
            return { 
                html: cardHtml, 
                chartData: {
                    id: chartId,
                    datasets: allDatasets,
                    title: `Time Series Traces (Total Traces: ${allDatasets.length})`
                }
            };
        }

        // --- Batch Loading Function (Unchanged) ---
        async function loadAllFilteredDataFrames() {
            if (currentlyRenderedFiles.length === 0) {
                contentTitle.textContent = "No Files Selected";
                fileContentDisplay.innerHTML = '<div class="error">The filtered list is empty. Apply different filters and try again.</div>';
                return;
            }

            contentTitle.textContent = `Loading ${currentlyRenderedFiles.length} DataFrames...`;
            fileContentDisplay.innerHTML = `<span class="loading">Preparing to load ${currentlyRenderedFiles.length} files. This may take a moment...</span>`;
            
            const dataFilesToLoad = currentlyRenderedFiles.filter(item => item.source && item.type === 'file');

            let allCardsHtml = '';
            const allChartData = []; 
            let successfulLoads = 0;
            
            for (const item of dataFilesToLoad) {
                const result = await loadSingleDataFrameAndGetChart(item.url, item.name, item);
                
                if (result.success) {
                    allCardsHtml += result.html;
                    if (result.chartData) {
                        allChartData.push(result.chartData);
                    }
                    successfulLoads++;
                } else {
                    allCardsHtml += `<div class="data-card-container error"><h3>Error loading ${item.name}</h3><p class="error-message">${result.error}</p></div>`;
                }
            }
            
            contentTitle.textContent = `Batch Load Complete: ${successfulLoads} DataFrames Charted`;
            
            fileContentDisplay.innerHTML = allCardsHtml;
            
            allChartData.forEach(data => {
                initializeChart(data.id, data.datasets, data.title);
            });

            if (successfulLoads === 0) {
                 fileContentDisplay.innerHTML = `<div class="error">Failed to load or chart any of the filtered DataFrames. Check the console for individual file errors.</div>`;
            }
        }
        
        // --- Data Loading and Charting Functions (Unchanged) ---

        async function loadSingleDataFrameAndGetChart(apiUrl, fileName, fileInfo) {
            try {
                if (typeof pako === 'undefined') {
                     throw new Error("pako library is missing. Cannot decompress Gzip (.gz) files.");
                }
                if (typeof Chart === 'undefined') {
                     throw new Error("Chart.js library is missing. Cannot generate charts.");
                }
                if (!fileInfo || !fileInfo.name) {
                     throw new Error("File metadata missing.");
                }

                const apiResponse = await fetch(apiUrl);
                if (!apiResponse.ok) {
                    const errorData = await apiResponse.json().catch(() => ({ message: 'Unknown API error' }));
                    throw new Error(`API error! Status: ${apiResponse.status} - ${errorData.message || 'File not accessible via API.'}`);
                }
                const fileData = await apiResponse.json();
                const downloadUrl = fileData.download_url;
                if (!downloadUrl) throw new Error("Could not find raw download URL for the file.");

                const rawResponse = await fetch(downloadUrl);
                if (!rawResponse.ok) throw new Error(`Raw download error! Status: ${rawResponse.status}`);
                const compressedBuffer = await rawResponse.arrayBuffer();
                
                const decompressedUint8Array = pako.ungzip(compressedBuffer);
                const rawContentString = new TextDecoder('utf-8').decode(decompressedUint8Array);
                
                if (rawContentString === '{}' || rawContentString === '[]' || rawContentString.trim().length === 0) {
                    throw new Error("Decompressed JSON content is empty.");
                }

                const dataObject = JSON.parse(rawContentString);
                
                const chartResult = jsonToChartCard(dataObject, fileInfo);

                return { success: true, html: chartResult.html, chartData: chartResult.chartData, error: null };

            } catch (error) {
                console.error(`Error loading file ${fileName}:`, error);
                return { success: false, html: null, chartData: null, error: error.message };
            }
        }

        async function loadDataFrameChart(apiUrl, fileName) {
            contentTitle.textContent = `Loading Chart: ${fileName}... (Individual file loading disabled)`;
            fileContentDisplay.innerHTML = '<div class="error">Individual file loading is currently disabled. Use the filters and the "Load ALL" button.</div>';
        }

        // --- Remaining Utility Functions (Unchanged) ---
        
        function getSelectedValues(id) {
            const select = document.getElementById(id);
            if (!select) return [];
            
            return Array.from(select.options)
                        .filter(option => option.selected)
                        .map(option => option.value)
                        .filter(value => value !== ""); 
        }

        function parseFileName(fileName) {
            if (!fileName.toLowerCase().endsWith('.json.gz') && !fileName.toLowerCase().endsWith('.json')) {
                return null;
            }
            
            const baseName = fileName.replace(/\.json\.gz$/, '').replace(/\.json$/, '');
            const parts = baseName.split('__'); 
            
            if (parts.length === 4) {
                return {
                    name: fileName,
                    source: parts[0],
                    instrument: parts[1],
                    category: parts[2],
                    date: parts[3],
                    match: true,
                };
            }
            return null; 
        }

        function populateFilters(metadataList) {
            const fields = ['source', 'instrument', 'category', 'date'];
            const uniqueValues = {};

            fields.forEach(field => uniqueValues[field] = new Set());

            metadataList.forEach(item => {
                if (item.source) { 
                    fields.forEach(field => uniqueValues[field].add(item[field]));
                }
            });

            fields.forEach(field => {
                const selectElement = document.getElementById(`select-${field}`);
                selectElement.innerHTML = ''; 

                let sortedValues = Array.from(uniqueValues[field]);
                if (field === 'date') {
                    sortedValues.sort((a, b) => b.localeCompare(a)); 
                } else {
                    sortedValues.sort();
                }

                sortedValues.forEach(value => {
                    if (value) {
                        const option = document.createElement('option');
                        option.value = value;
                        option.textContent = value;
                        selectElement.appendChild(option);
                    }
                });
            });
        }

        function applyFilters() {
            const selectedSources = getSelectedValues('select-source');
            const selectedCategories = getSelectedValues('select-category');
            const selectedInstruments = getSelectedValues('select-instrument');
            const selectedDates = getSelectedValues('select-date');
            
            const filteredList = allFileMetadata.filter(item => {
                if (item.type === 'dir') return true; 
                if (!item.source) return false; 

                const matchSource = selectedSources.length === 0 || selectedSources.includes(item.source);
                const matchCategory = selectedCategories.length === 0 || selectedCategories.includes(item.category);
                const matchInstrument = selectedInstruments.length === 0 || selectedInstruments.includes(item.instrument);
                const matchDate = selectedDates.length === 0 || selectedDates.includes(item.date);

                return matchSource && matchCategory && matchInstrument && matchDate;
            });
            
            currentlyRenderedFiles = filteredList; 
        }

        async function init() {
            try {
                // Load config and store it globally
                const config = await loadConfig();
                appConfig = config; 
                
                // 1. Fetch contents and populate filters
                await fetchRepoContents(config.githubRepo, config.basePath);
                
                // 2. Load bookmarked files (will check config first now)
                const bookmarked = await loadBookmarkedFiles();
                
                if (!bookmarked) {
                    applyFilters(); 
                }

            } catch (error) {
                console.error('Initialization error:', error);
                displayError(`Initialization Failed: ${error.message}. Please ensure 'config.json' is valid and you are using a web server.`);
            }
        }

        async function loadConfig() {
            const response = await fetch('config.json');
            if (!response.ok) throw new Error(`Failed to load config.json. Status: ${response.status}`);
            const config = await response.json();
            if (!config.githubRepo || !config.basePath) {
                throw new Error("config.json must contain 'githubRepo' and 'basePath' fields.");
            }
            return config;
        }

        async function fetchRepoContents(ownerRepo, path) {
            const cleanOwnerRepo = ownerRepo.trim().replace(/^\/|\/$/g, '');
            const cleanPath = path.trim().replace(/^\/|\/$/g, '');
            const apiUrl = `https://api.github.com/repos/${cleanOwnerRepo}/contents/${cleanPath}`;
            
            const response = await fetch(apiUrl);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `HTTP error! Status: ${response.status}`);
            }

            const contents = await response.json();
            
            allFileMetadata = contents.map(item => {
                if (item.type === 'file') {
                    const parsed = parseFileName(item.name);
                    return parsed ? { ...item, ...parsed } : item; 
                }
                return item;
            });

            populateFilters(allFileMetadata);
            currentlyRenderedFiles = allFileMetadata; 
        }
        
        async function loadAndDisplayFileContent(apiUrl, fileName) {
            contentTitle.textContent = `File Content Display Disabled: ${fileName}`;
            fileContentDisplay.innerHTML = '<div class="error">Individual file content display is currently disabled. Use filters to load charts.</div>';
        }

        function displayError(message) {
            contentTitle.textContent = 'ERROR';
            fileContentDisplay.innerHTML = `<div class="error">${message}</div>`;
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>