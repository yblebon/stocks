<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Financial Data Product Viewer</title> 
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.1.0/dist/chartjs-adapter-luxon.min.js"></script>


    <style>
        /* --- FONT STACK --- */
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif; 
        }
        
        /* Centered Main Title Styling (Now contained within a grid cell) */
        #header-title {
            text-align: left; /* Aligned left within its cell */
            font-size: 2.2em;
            margin: 0; 
            line-height: 1.2;
        }

        /* --- Header Row Container for Title and Clocks --- */
        #main-header-row {
            border-bottom: 2px solid #e1e1e1;
            margin-bottom: 20px;
            padding-bottom: 10px;
            align-items: center; /* Vertically center content in the row */
        }


        /* Time Display Styling (Modified for inline placement) */
        #time-display {
            padding: 0;
            margin: 0; 
            display: flex;
            flex-wrap: wrap; 
            gap: 15px;
            font-size: 0.9em;
            align-items: center;
            justify-content: flex-end; /* Align clocks to the right */
        }
        .time-entry {
            padding: 5px 10px;
            background-color: #f7f7f7; /* Light background for separation */
            border-radius: 3px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            min-width: 120px;
        }
        .time-entry strong {
            display: block;
            font-size: 0.8em;
            color: #555;
            margin-bottom: 2px;
        }
        .time-entry span {
            font-weight: bold;
            color: #007bff;
        }
        
        /* --- Tag Search Container Styling --- */
        #tag-search-container {
            margin-bottom: 20px;
            border: 1px solid #e1e1e1;
            padding: 15px;
            border-radius: 5px;
            background-color: #fcfcfc;
        }
        /* Style the input field to look like a tag input area */
        #tag-input-field {
            width: 100%;
            border-color: #ccc;
            padding: 10px;
            box-shadow: none;
            font-size: 1em;
            height: 50px; 
            margin-bottom: 0; 
        }
        /* Style for the inline button */
        .inline-button {
            height: 50px; 
            margin-top: 0;
        }
        
        /* --- Applied Filters Display --- */
        #applied-filters-display {
            padding: 5px 0 10px 0;
            border-top: 1px solid #eee;
            margin-top: 15px;
            min-height: 40px; /* Ensure space even when empty */
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 5px;
        }
        .applied-tag {
            background-color: #007bff;
            color: white;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            font-weight: bold;
            display: inline-block;
        }
        
        /* Content Title (Labels) Styling */
        #content-title {
            font-size: 1.2em; 
            font-weight: 600; 
            border-bottom: 2px solid #e1e1e1; 
            padding-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 5px; 
            margin-top: 15px; 
        }
        
        /* Specific styling for the initial title text */
        #content-title h3 {
            margin: 0;
            font-size: 1.2em;
            font-weight: 600;
        }
        
        /* Custom Label Styling */
        .label {
            line-height: 1.5;
            padding: 0.4em 0.8em;
            font-weight: normal; 
        }

        /* Filter Card (Simplified) */
        #filter-card {
            padding: 10px; 
        }
        
        /* Chart Card Notes/Errors */
        .note {
            font-size: 0.8em;
            color: #777;
            margin-top: 10px;
        }
        .error-message {
            color: #cc0000;
            font-weight: bold;
        }

        /* Chart Wrapper: Fixed height */
        .chart-wrapper {
            height: 300px; 
            width: 100%;
            margin-top: 15px;
        }
        
        /* Responsive Data Table */
        .data-table-container {
            max-height: 300px;
            overflow: auto;
            border: 1px solid #ccc;
            background-color: #fff;
            padding: 5px;
            display: none;
        }
        .data-table-container table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8em;
        }
        .data-table-container th {
            background-color: #f0f0f0;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        /* Custom Bookmark Button Overrides */
        .button.warning {
            background-color: #f0ad4e; 
            color: #333;
        }
        .button.warning:hover {
            background-color: #ec971f;
        }
    </style>
</head>
<body>
    
    <div class="grid-container">

        <div id="main-header-row" class="grid-x grid-margin-x">
            
            <div class="medium-4 cell">
                <h1 id="header-title">Financial Data Product Viewer</h1>
            </div>

            <div class="medium-8 cell">
                <div id="time-display">
                    Loading clocks... ‚è±Ô∏è
                </div>
            </div>
        </div>

        <div id="tag-search-container">
            <label for="tag-input-field">
                Add Filter Tag (e.g., **Source:ABC**, **20251202** (YYYYMMDD), or just **ABC**) - **Press ENTER to apply filter**:
            </label>
            <div class="grid-x grid-margin-x align-middle">
                <div class="auto cell">
                    <input type="text" 
                        id="tag-input-field" 
                        placeholder="Enter tags separated by commas, then press ENTER.">
                </div>
                
                <div class="shrink cell">
                    <button id="tag-load-button" onclick="loadFilesByTagInput()" class="button alert inline-button">
                        Load üìä
                    </button>
                </div>
                <div class="shrink cell">
                    <button id="tag-clear-button" onclick="clearFiltersAndReload()" class="button secondary inline-button">
                        Clear ‚ùå
                    </button>
                </div>
            </div>
            
            <div id="applied-filters-display">
                <span class="note">No filters applied.</span>
            </div>
        </div>
        
        <div class="grid-x grid-margin-x">
            
            <div class="medium-3 cell">
                
                <div id="filter-card" class="callout">
                    
                    <h5 class="text-center">Filter Information</h5>
                    <p class="note">Criteria stack up using **AND** logic in the search bar above.</p>
                </div>
            </div>

            <div class="medium-9 cell">
                <div id="content-title">Select a File</div>
                <div id="file-content-display">
                    Use the tag search field and click **Load üìä** to view multiple charts here.
                </div>
            </div>

        </div> </div> <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"></script>

    <script>
        // Store config globally to access initialBookmarks
        let appConfig = {}; 
        
        // --- Global array to store applied filter strings ---
        let appliedFilterStrings = []; 
        
        // Mock objects for removed HTML elements
        const contentsList = { innerHTML: '' }; 
        const currentPathDisplay = { textContent: '', classList: { remove: () => {} } }; 

        // DOM elements
        const fileContentDisplay = document.getElementById('file-content-display');
        const contentTitle = document.getElementById('content-title');
        const tagInputField = document.getElementById('tag-input-field');
        const appliedFiltersDisplay = document.getElementById('applied-filters-display');

        let allFileMetadata = []; 
        let currentlyRenderedFiles = [];
        const rawDataStore = new Map(); 

        const BOOKMARK_KEY = 'dataframe-bookmarked-files'; 
        
        // Map friendly tag names to the internal metadata keys
        const TAG_FIELD_MAP = {
            'SOURCE': 'source',
            'CATEGORY': 'category',
            'INSTRUMENT': 'instrument',
            'DATE': 'date'
        };

        // --- Time Zone Logic (Unchanged) ---
        const TIME_ZONES = [
            { name: "New York", zone: "America/New_York" },
            { name: "London", zone: "Europe/London" },
            { name: "Paris", zone: "Europe/Paris" },
            { name: "UTC", zone: "UTC" },
            { name: "Local", zone: Intl.DateTimeFormat().resolvedOptions().timeZone },
            { name: "Moscow", zone: "Europe/Moscow" },
            { name: "Tokyo", zone: "Asia/Tokyo" }
        ];

        function updateClocks() {
            const now = new Date();
            const timeData = [];

            TIME_ZONES.forEach(tz => {
                try {
                    const options = {
                        hour: '2-digit', minute: '2-digit', second: '2-digit',
                        hour12: false, 
                        timeZone: tz.zone
                    };
                    
                    const timeString = now.toLocaleTimeString('en-US', options);
                    
                    const timeInZone = new Date(now.toLocaleString('en-US', { timeZone: tz.zone }));

                    timeData.push({
                        name: tz.name,
                        timeString: timeString,
                        timeInZone: timeInZone 
                    });
                } catch (e) {
                    console.error(`Error fetching time for ${tz.name}:`, e);
                    timeData.push({ name: tz.name, timeString: 'Error', timeInZone: new Date(0) });
                }
            });

            timeData.sort((a, b) => a.timeInZone.getTime() - b.timeInZone.getTime());

            const timeDisplay = document.getElementById('time-display');
            let html = '';

            timeData.forEach(data => {
                html += `
                    <div class="time-entry">
                        <strong>${data.name}</strong>
                        <span>${data.timeString}</span>
                    </div>
                `;
            });
            
            timeDisplay.innerHTML = html;
        }

        updateClocks();
        setInterval(updateClocks, 1000); 
        // --- END Time Zone Logic ---

        // Simple utility function to generate stable colors for different columns
        function getColor(index) {
            const colors = [
                'rgb(75, 192, 192)', // Teal
                'rgb(255, 99, 132)', // Red
                'rgb(54, 162, 235)', // Blue
                'rgb(255, 206, 86)', // Yellow
                'rgb(153, 102, 255)',// Purple
                'rgb(255, 159, 64)', // Orange
                'rgb(201, 203, 207)' // Grey
            ];
            return colors[index % colors.length];
        }
        // -----------------------------------------------------------


        // --- Helper function for Label generation ---

        const formatLabel = (set, fieldName, colorClass) => {
            if (set.size === 0) return '';
            const values = Array.from(set).sort().join(', ');
            return `<span class="label ${colorClass}">${fieldName}: ${values}</span>`;
        };

        function generateLoadLabels(filesToReport) {
            if (filesToReport.length === 0) return '';
            
            const uniqueValues = { source: new Set(), instrument: new Set(), category: new Set(), date: new Set() };

            filesToReport.forEach(file => {
                uniqueValues.source.add(file.source);
                uniqueValues.instrument.add(file.instrument);
                uniqueValues.category.add(file.category);
                uniqueValues.date.add(file.date);
            });

            return `
                ${formatLabel(uniqueValues.source, 'Source', 'primary')}
                ${formatLabel(uniqueValues.instrument, 'Instruments', 'secondary')}
                ${formatLabel(uniqueValues.category, 'Categories', 'success')}
                ${formatLabel(uniqueValues.date, 'Dates', 'warning')}
            `;
        }
        
        // --- Function to render the applied filters ---
        function renderAppliedFilters() {
            if (appliedFilterStrings.length === 0) {
                appliedFiltersDisplay.innerHTML = '<span class="note">No filters applied.</span>';
                return;
            }
            
            let html = '<span class="note" style="margin-right: 10px;">Applied Filters (AND):</span>';
            appliedFilterStrings.forEach(filterStr => {
                html += `<span class="applied-tag">${filterStr}</span>`;
            });
            appliedFiltersDisplay.innerHTML = html;
        }

        // --- Tag Parsing Functions (MODIFIED) ---

        /**
         * Parses a single tag string into structured criteria, separating explicit Key:Value
         * tags from literal search terms, and handling implicit YYYYMMDD dates.
         * @param {string} tagString - e.g., "Source:EUREX, 20251202, oil"
         * @returns {object} - { criteria: { source: ['EUREX'], date: ['20251202'], ... }, literalTerms: ['oil'] }
         */
        function parseTagsFromInput(tagString) {
            const criteria = { source: [], category: [], instrument: [], date: [] };
            const literalTerms = [];
            if (!tagString) return { criteria, literalTerms };

            // Regex to find a YYYYMMDD format (8 digits)
            const dateRegex = /^(\d{4})(\d{2})(\d{2})$/;

            // Split by comma, then trim and filter empty entries
            const rawTags = tagString.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);

            rawTags.forEach(rawTag => {
                const parts = rawTag.split(':');
                if (parts.length === 2) {
                    // 1. Explicit Key:Value tag
                    const rawKey = parts[0].trim().toUpperCase();
                    const value = parts[1].trim();
                    const internalKey = TAG_FIELD_MAP[rawKey];
                    
                    if (internalKey && value) {
                        criteria[internalKey].push(value);
                    }
                } else {
                    // 2. Literal search term (Check for YYYYMMDD)
                    const match = rawTag.match(dateRegex);
                    
                    if (match) {
                        // Found YYYYMMDD date. Use the raw input string directly for comparison 
                        // against the file metadata, which is likely also YYYYMMDD.
                        criteria.date.push(rawTag);
                    } else {
                        // Regular literal search term
                        literalTerms.push(rawTag.toLowerCase());
                    }
                }
            });
            
            return { criteria, literalTerms };
        }
        
        /**
         * Parses all applied filter strings into a single, aggregated criteria object
         * and a list of all literal terms.
         * @returns {object} - { allCriteria: [ { source: [...] }, ... ], allLiteralTerms: [...] }
         */
        function parseAllAppliedFilters() {
            const allCriteria = [];
            const allLiteralTerms = [];
            
            appliedFilterStrings.forEach(filterString => {
                const parsed = parseTagsFromInput(filterString);
                
                // Aggregate explicit criteria
                if (Object.values(parsed.criteria).some(arr => arr.length > 0)) {
                    allCriteria.push(parsed.criteria);
                }
                
                // Aggregate literal terms
                allLiteralTerms.push(...parsed.literalTerms);
            });
            
            // Remove duplicates from literal terms
            const uniqueLiteralTerms = [...new Set(allLiteralTerms)];
            
            return { allCriteria, allLiteralTerms: uniqueLiteralTerms };
        }

        // --- Core Load Logic (Unchanged) ---

        async function loadFilesByTagInput() {
            const { allCriteria: allCriteriaSets, allLiteralTerms } = parseAllAppliedFilters();
            
            let filteredList = allFileMetadata;
            
            if (allCriteriaSets.length === 0 && allLiteralTerms.length === 0) {
                // If no filters, show all files
                currentlyRenderedFiles = allFileMetadata;
            } else {
                 filteredList = allFileMetadata.filter(item => {
                    if (item.type === 'dir' || !item.source) return false; 
                    
                    // --- 1. Check Explicit Key:Value Criteria (AND logic across all sets) ---
                    const explicitMatch = allCriteriaSets.every(criteria => {
                        
                        // Check if the item matches any value provided for each specific field in this criteria set
                        // (OR logic within the field's values)
                        
                        // NOTE: This includes the implicitly added date criteria from YYYYMMDD input
                        const matchSource = criteria.source.length === 0 || criteria.source.includes(item.source);
                        const matchCategory = criteria.category.length === 0 || criteria.category.includes(item.category);
                        const matchInstrument = criteria.instrument.length === 0 || criteria.instrument.includes(item.instrument);
                        const matchDate = criteria.date.length === 0 || criteria.date.includes(item.date);
                        
                        // For a criteria set to pass, it must match all specified fields (AND logic)
                        return matchSource && matchCategory && matchInstrument && matchDate;
                    });
                    
                    // --- 2. Check Literal Terms (AND logic across all literal terms) ---
                    const literalMatch = allLiteralTerms.every(term => {
                        const lowerTerm = term.toLowerCase();
                        
                        // The file must contain the literal term in at least one metadata field (OR logic)
                        const sourceMatch = item.source && item.source.toLowerCase().includes(lowerTerm);
                        const categoryMatch = item.category && item.category.toLowerCase().includes(lowerTerm);
                        const instrumentMatch = item.instrument && item.instrument.toLowerCase().includes(lowerTerm);
                        
                        // NOTE: We don't search the 'date' field for literal terms as that is now handled 
                        // by the explicit check above, preventing partial date matches.
                        
                        return sourceMatch || categoryMatch || instrumentMatch;
                    });

                    // --- Final Result: Must match ALL Explicit AND ALL Literal terms ---
                    return explicitMatch && literalMatch;
                });
                currentlyRenderedFiles = filteredList;
            }

            
            // Now, execute the load process
            await loadAllFilteredDataFrames();
        }

        // --- Keypress Handler for Enter Key (Unchanged) ---
        tagInputField.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault(); 
                const newFilter = tagInputField.value.trim();
                if (newFilter) {
                    // 1. Add new filter string
                    appliedFilterStrings.push(newFilter);
                    
                    // 2. Clear input field
                    tagInputField.value = '';
                    
                    // 3. Update visual feedback
                    renderAppliedFilters();
                    
                    // 4. Run the load
                    loadFilesByTagInput();
                }
            }
        });
        
        // --- Clear Filters and Reload Function (Unchanged) ---
        function clearFiltersAndReload() {
            appliedFilterStrings = [];
            renderAppliedFilters();
            tagInputField.value = '';
            // Reload all files (as loadFilesByTagInput will see an empty filter list)
            loadFilesByTagInput(); 
        }

        // --- Batch Loading Function (Relies on currentlyRenderedFiles) ---
        async function loadAllFilteredDataFrames() {
            if (currentlyRenderedFiles.length === 0) {
                contentTitle.innerHTML = '<h3>No Files Selected</h3>'; 
                fileContentDisplay.innerHTML = '<div class="callout alert">No files matched the current tag criteria. Try different tags or clear filters.</div>';
                return;
            }

            contentTitle.innerHTML = `<h3>Loading ${currentlyRenderedFiles.length} DataFrames...</h3>`; 
            fileContentDisplay.innerHTML = `<div class="callout"><span class="loading">Preparing to load ${currentlyRenderedFiles.length} files. This may take a moment...</span></div>`;
            
            const dataFilesToLoad = currentlyRenderedFiles.filter(item => item.source && item.type === 'file');

            let allCardsHtml = '';
            const allChartData = []; 
            const loadedFileInfos = []; 
            
            for (const item of dataFilesToLoad) {
                const result = await loadSingleDataFrameAndGetChart(item.url, item.name, item);
                
                if (result.success) {
                    allCardsHtml += result.html;
                    if (result.chartData) {
                        allChartData.push(result.chartData);
                    }
                    loadedFileInfos.push(item);
                } else {
                    allCardsHtml += `<div class="callout alert"><h3>Error loading ${item.name}</h3><p class="error-message">${result.error}</p></div>`;
                }
            }
            
            fileContentDisplay.innerHTML = allCardsHtml;
            
            allChartData.forEach(data => {
                initializeChart(data.id, data.datasets, data.title);
            });
            
            // Use aggregated labels for successful load
            if (loadedFileInfos.length > 0) {
                contentTitle.innerHTML = generateLoadLabels(loadedFileInfos);
            } else {
                 contentTitle.innerHTML = `<h3>Charts Failed to Load</h3>`;
                 fileContentDisplay.innerHTML = `<div class="callout alert">Failed to load or chart any of the filtered DataFrames. Check the console for individual file errors.</div>`;
            }
        }
        
        // --- Bookmark Functions (Unchanged) ---

        function getBookmarkedFiles() {
            if (appConfig.initialBookmarks && Array.isArray(appConfig.initialBookmarks) && appConfig.initialBookmarks.length > 0) {
                 const uniqueBookmarks = [...new Set(appConfig.initialBookmarks)];
                 console.log("Loaded initial bookmarks from config.json.");
                 return uniqueBookmarks;
            }
            
            try {
                const saved = localStorage.getItem(BOOKMARK_KEY);
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                console.error('Error reading bookmarks from local storage:', e);
                return [];
            }
        }

        function saveBookmarkedFiles(fileNames) {
            try {
                localStorage.setItem(BOOKMARK_KEY, JSON.stringify(fileNames));
            } catch (e) {
                console.error('Error saving bookmarks to local storage:', e);
            }
        }

        function toggleFileBookmark(fileName, buttonId) {
            let currentLocalBookmarks = [];
            try {
                const saved = localStorage.getItem(BOOKMARK_KEY);
                currentLocalBookmarks = saved ? JSON.parse(saved) : (appConfig.initialBookmarks || []);
            } catch(e) { /* ignore */ }
            
            let workingSet = [...currentLocalBookmarks];

            const index = workingSet.indexOf(fileName);
            const button = document.getElementById(buttonId);
            
            if (index > -1) {
                workingSet.splice(index, 1);
                button.textContent = 'Bookmark this Chart ‚≠êÔ∏è';
                button.classList.remove('warning'); 
                button.classList.add('success'); 
                console.log(`Removed bookmark for: ${fileName}`);
            } else {
                workingSet.push(fileName);
                button.textContent = 'Bookmarked! (Click to Remove) ‚úÖ';
                button.classList.remove('success');
                button.classList.add('warning');
                console.log(`Added bookmark for: ${fileName}`);
            }
            
            saveBookmarkedFiles(workingSet);
        }

        async function loadBookmarkedFiles() {
            const bookmarkedFileNames = getBookmarkedFiles();
            
            if (bookmarkedFileNames.length === 0) return false;

            const bookmarkedFilesInfo = allFileMetadata.filter(item => 
                bookmarkedFileNames.includes(item.name)
            );

            if (bookmarkedFilesInfo.length > 0) {
                currentlyRenderedFiles = bookmarkedFilesInfo;
                await loadAllFilteredDataFrames(); 

                // Re-update title specifically for the bookmark load if successful
                const filesThatLoaded = currentlyRenderedFiles.filter(item => item.source); 
                contentTitle.innerHTML = generateLoadLabels(filesThatLoaded);
                
                return true;
            }
            contentTitle.innerHTML = '<h3>Bookmarked files not found in repository.</h3>';
            return false;
        }
        
        // --- Data Table Functions (Unchanged) ---

        function renderTable(dataObject, tableContainerId) {
            const container = document.getElementById(tableContainerId);
            if (!container) return;

            const indices = Object.keys(dataObject);
            if (indices.length === 0) {
                container.innerHTML = '<table><tr><td>No data records found.</td></tr></table>';
                return;
            }

            const columns = ['Index (Date/Time)', ...Object.keys(dataObject[indices[0]])];
            
            let html = '<table><thead><tr>';
            columns.forEach(col => {
                html += `<th>${col}</th>`;
            });
            html += '</tr></thead><tbody>';

            const rowsToDisplay = indices.slice(0, 50);

            rowsToDisplay.forEach(index => {
                const row = dataObject[index];
                html += '<tr>';

                let displayIndex = index;
                const indexNum = Number(index);
                if (!isNaN(indexNum) && String(index).length === 13) {
                    try {
                        displayIndex = luxon.DateTime.fromMillis(indexNum).toFormat('yyyy-MM-dd HH:mm:ss');
                    } catch (e) {
                        displayIndex = index;
                    }
                }
                
                html += `<td>${displayIndex}</td>`; 
                
                columns.slice(1).forEach(col => {
                    const value = row[col];
                    const formattedValue = (typeof value === 'number' && !Number.isInteger(value)) 
                        ? value.toFixed(4) : value;
                    html += `<td>${formattedValue}</td>`;
                });
                html += '</tr>';
            });

            if (indices.length > 50) {
                html += `<tr><td colspan="${columns.length}" style="text-align:center; font-style:italic;">... Showing first 50 of ${indices.length} rows ...</td></tr>`;
            }

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function toggleDataTable(chartId, cardId) {
            const chartWrapper = document.getElementById(`${cardId}-chart-wrapper`);
            const tableContainer = document.getElementById(`${cardId}-table-container`);
            const button = document.getElementById(`${cardId}-toggle-button`);
            const rawData = rawDataStore.get(chartId); 

            if (!chartWrapper || !tableContainer || !button || !rawData) return;

            if (chartWrapper.style.display !== 'none') {
                renderTable(rawData, `${cardId}-table-container`);
                chartWrapper.style.display = 'none';
                tableContainer.style.display = 'block';
                button.textContent = 'Hide Source Data üìà';
            } else {
                tableContainer.style.display = 'none';
                chartWrapper.style.display = 'block';
                button.textContent = 'Show Source Data üìã';
            }
        }

        // --- Core Chart Initialization Function (Unchanged) ---
        function initializeChart(chartId, datasets, title) {
            const ctx = document.getElementById(chartId);
            if (!ctx) return; 

            if (Chart.getChart(ctx)) {
                Chart.getChart(ctx).destroy();
            }
            
            const chartDatasets = datasets.map((d, index) => { 
                const color = getColor(index);
                return {
                    label: d.label,
                    data: d.data,
                    borderColor: color,
                    backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.2)'),
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1,
                    hidden: index !== 0 
                };
            });


            new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: chartDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true, 
                            position: 'bottom',
                            labels: {
                                usePointStyle: true
                            }
                        },
                        title: { 
                            display: true,
                            text: title
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                parser: false, 
                                unit: 'day',
                                tooltipFormat: 'yyyy-MM-dd HH:mm',
                                displayFormats: {
                                    day: 'yyyy-MM-dd',
                                    hour: 'HH:mm'
                                }
                            },
                            title: { display: true, text: 'Date (YYYY-MM-DD)' },
                            ticks: { 
                                maxTicksLimit: 10,
                                autoSkip: true
                            }
                        },
                        y: {
                            title: { display: true, text: 'Value' }
                        }
                    }
                }
            });
        }
        
        // --- Helper Function for Chart Card Generation (Unchanged) ---
        function jsonToChartCard(dataObject, fileInfo) {
            const indices = Object.keys(dataObject);
            const numRecords = indices.length;
            const cardId = `card-${fileInfo.name.replace(/[^a-zA-Z0-9]/g, '_')}`; 
            const chartId = `chart-${fileInfo.name.replace(/[^a-zA-Z0-9]/g, '_')}`; 
            const buttonId = `${cardId}-bookmark-button`;
            
            rawDataStore.set(chartId, dataObject);

            const isBookmarked = getBookmarkedFiles().includes(fileInfo.name);
            const bookmarkText = isBookmarked ? 'Bookmarked! (Click to Remove) ‚úÖ' : 'Bookmark this Chart ‚≠êÔ∏è';
            
            const bookmarkClass = isBookmarked ? 'button warning' : 'button success';


            let metadataHtml = `
                <h3>${fileInfo.source} | ${fileInfo.instrument} | ${fileInfo.category} | ${fileInfo.date}</h3>
                <p class="note">${numRecords} total records found. Chart displays the first 100 data points. **Handles both ISO date strings and millisecond timestamps.** Click the legend items to toggle traces.</p>
            `;

            if (numRecords === 0) {
                return { 
                    html: `<div class="callout" id="${cardId}">${metadataHtml}<p class="error-message">DataFrame is empty.</p></div>`,
                    chartData: null
                };
            }

            const firstRecord = dataObject[indices[0]];
            if (!firstRecord) {
                 return { 
                    html: `<div class="callout" id="${cardId}">${metadataHtml}<p class="error-message">DataFrame has records but the first one is invalid.</p></div>`,
                    chartData: null
                };
            }

            const availableColumns = Object.keys(firstRecord);
            const allDatasets = [];
            
            const rowsToDisplay = indices.slice(0, 100);
            
            for (const col of availableColumns) {
                const dataPoints = [];
                let hasNumericData = false;

                rowsToDisplay.forEach(dateString => {
                    const value = dataObject[dateString][col];
                    const numericValue = parseFloat(value);

                    const indexNum = Number(dateString);
                    const isTimestamp = !isNaN(indexNum) && String(dateString).length === 13;
                    const xValue = isTimestamp ? indexNum : dateString; 

                    if (isNaN(numericValue)) {
                        dataPoints.push({ x: xValue, y: null });
                    } else {
                        dataPoints.push({ x: xValue, y: numericValue });
                        hasNumericData = true;
                    }
                });

                if (hasNumericData) {
                    allDatasets.push({
                        label: col.charAt(0).toUpperCase() + col.slice(1), 
                        data: dataPoints 
                    });
                }
            }
            
            if (allDatasets.length === 0) {
                 return {
                    html: `<div class="callout alert" id="${cardId}">
                        ${metadataHtml}
                        <p class="error-message">Error: No numeric columns found in this DataFrame to plot.</p>
                    </div>`,
                    chartData: null
                };
            }


            const cardHtml = `
                <div class="callout" id="${cardId}">
                    ${metadataHtml}
                    
                    <button class="button secondary" id="${cardId}-toggle-button" 
                            onclick="toggleDataTable('${chartId}', '${cardId}')">
                        Show Source Data üìã
                    </button>
                    
                    <button class="${bookmarkClass}" id="${buttonId}" 
                            onclick="toggleFileBookmark('${fileInfo.name}', '${buttonId}')">
                        ${bookmarkText}
                    </button>

                    <div class="chart-wrapper" id="${cardId}-chart-wrapper" style="display: block;">
                        <canvas id="${chartId}"></canvas>
                    </div>

                    <div class="data-table-container" id="${cardId}-table-container" style="display: none;">
                    </div>
                </div>
            `;
            
            return { 
                html: cardHtml, 
                chartData: {
                    id: chartId,
                    datasets: allDatasets,
                    title: `Time Series Traces (Total Traces: ${allDatasets.length})`
                }
            };
        }

        // --- Data Loading and Charting Functions (Unchanged) ---

        async function loadSingleDataFrameAndGetChart(apiUrl, fileName, fileInfo) {
            try {
                if (typeof pako === 'undefined') {
                     throw new Error("pako library is missing. Cannot decompress Gzip (.gz) files.");
                }
                if (typeof Chart === 'undefined') {
                     throw new Error("Chart.js library is missing. Cannot generate charts.");
                }
                if (!fileInfo || !fileInfo.name) {
                     throw new Error("File metadata missing.");
                }

                const apiResponse = await fetch(apiUrl);
                if (!apiResponse.ok) {
                    const errorData = await apiResponse.json().catch(() => ({ message: 'Unknown API error' }));
                    throw new Error(`API error! Status: ${apiResponse.status} - ${errorData.message || 'File not accessible via API.'}`);
                }
                const fileData = await apiResponse.json();
                const downloadUrl = fileData.download_url;
                if (!downloadUrl) throw new Error("Could not find raw download URL for the file.");

                const rawResponse = await fetch(downloadUrl);
                if (!rawResponse.ok) throw new Error(`Raw download error! Status: ${rawResponse.status}`);
                const compressedBuffer = await rawResponse.arrayBuffer();
                
                const decompressedUint8Array = pako.ungzip(compressedBuffer);
                const rawContentString = new TextDecoder('utf-8').decode(decompressedUint8Array);
                
                if (rawContentString === '{}' || rawContentString === '[]' || rawContentString.trim().length === 0) {
                    throw new Error("Decompressed JSON content is empty.");
                }

                const dataObject = JSON.parse(rawContentString);
                
                const chartResult = jsonToChartCard(dataObject, fileInfo);

                return { success: true, html: chartResult.html, chartData: chartResult.chartData, error: null };

            } catch (error) {
                console.error(`Error loading file ${fileName}:`, error);
                return { success: false, html: null, chartData: null, error: error.message };
            }
        }

        async function loadDataFrameChart(apiUrl, fileName) {
            contentTitle.innerHTML = `<h3>Loading Chart: ${fileName}... (Individual file loading disabled)</h3>`;
            fileContentDisplay.innerHTML = '<div class="callout alert">Individual file content display is currently disabled. Use the tag input to load charts.</div>';
        }

        // --- Remaining Utility Functions (Simplified/Removed) ---
        
        // This function is no longer needed since we parse tags directly from the input field
        function getSelectedValues(id) { return []; } 

        function parseFileName(fileName) {
            if (!fileName.toLowerCase().endsWith('.json.gz') && !fileName.toLowerCase().endsWith('.json')) {
                return null;
            }
            
            const baseName = fileName.replace(/\.json\.gz$/, '').replace(/\.json$/, '');
            const parts = baseName.split('__'); 
            
            if (parts.length === 4) {
                return {
                    name: fileName,
                    source: parts[0],
                    instrument: parts[1],
                    category: parts[2],
                    date: parts[3], // This value must match the filter criteria exactly (e.g., "20251202")
                    match: true,
                };
            }
            return null; 
        }

        // This function is no longer needed as filters are removed
        function populateFilters(metadataList) {} 

        // This function is no longer needed as filters are removed
        function applyFilters() {} 

        async function init() {
            try {
                // Load config and store it globally
                const config = await loadConfig();
                appConfig = config; 
                
                // 1. Fetch contents
                await fetchRepoContents(config.githubRepo, config.basePath);
                
                // 2. Load bookmarked files (this sets currentlyRenderedFiles and loads the charts)
                const bookmarked = await loadBookmarkedFiles();
                
                if (!bookmarked) {
                    // If no bookmarks, just ensure the list is initialized to empty or everything
                    currentlyRenderedFiles = allFileMetadata;
                }
                
                // 3. Initialize Foundation JS components
                $(document).foundation();

            } catch (error) {
                console.error('Initialization error:', error);
                displayError(`Initialization Failed: ${error.message}. Please ensure 'config.json' is valid and you are using a web server.`);
            }
        }

        async function loadConfig() {
            const response = await fetch('config.json');
            if (!response.ok) throw new Error(`Failed to load config.json. Status: ${response.status}`);
            const config = await response.json();
            if (!config.githubRepo || !config.basePath) {
                throw new Error("config.json must contain 'githubRepo' and 'basePath' fields.");
            }
            return config;
        }

        async function fetchRepoContents(ownerRepo, path) {
            const cleanOwnerRepo = ownerRepo.trim().replace(/^\/|\/$/g, '');
            const cleanPath = path.trim().replace(/^\/|\/$/g, '');
            const apiUrl = `https://api.github.com/repos/${cleanOwnerRepo}/contents/${cleanPath}`;
            
            const response = await fetch(apiUrl);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `HTTP error! Status: ${response.status}`);
            }

            const contents = await response.json();
            
            allFileMetadata = contents.map(item => {
                if (item.type === 'file') {
                    const parsed = parseFileName(item.name);
                    return parsed ? { ...item, ...parsed } : item; 
                }
                return item;
            }).filter(item => item.source); // Filter out non-matching or directory entries immediately

            // Note: populateFilters is removed, so we just collect the metadata.
            currentlyRenderedFiles = allFileMetadata; 
        }
        
        async function loadAndDisplayFileContent(apiUrl, fileName) {
            contentTitle.innerHTML = `<h3>File Content Display Disabled: ${fileName}</h3>`;
            fileContentDisplay.innerHTML = '<div class="callout alert">Individual file content display is currently disabled. Use the tag input to load charts.</div>';
        }

        function displayError(message) {
            contentTitle.innerHTML = '<h3>ERROR</h3>';
            fileContentDisplay.innerHTML = `<div class="callout alert">${message}</div>`;
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>